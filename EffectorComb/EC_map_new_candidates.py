import pandas as pd
import numpy as np
import argparse


def minmax_scaler(f_min, f_max, f_value):
    f_std = (f_value - f_min)/(f_max - f_min)
    f_scaled = f_std * (1 - 0) + 0

    return f_scaled


if __name__ == '__main__':
    parser = argparse.ArgumentParser(usage="%(prog)s [options]",
                                     description="",
                                     epilog="")
    parser.add_argument("-ifl", "--input_feature_landscape",
                        help="original feature table of effector landscape generated by LEAPH")
    parser.add_argument("-i", "--input",
                        help="actual feature table generated by LEAPH")
    parser.add_argument("-lp", "--leaph_predictions",
                        help="output file (.tsv) of LEAPH prediction of effectors in the actual selection")
    parser.add_argument("-o", "--output_dir", default="../LEAPH_results/")
    parser.add_argument("-p", "--prefix")

    args = parser.parse_args()

    # as reference
    # ref_max = {'sequence length': 2026, 'signal peptide': 0.887, 'transmembrane domain': 18,
    #            'aa in tr domain': 390.62603, 'first 60 aa': 44.92594, 'prob N-in': 1.0,
    #            'warning signal sequence': 1, 'MobiDB-lite': 588.0,
    #            'CAMP_PHOSPHO_SITE': 6, 'PKC_PHOSPHO_SITE': 131, 'CK2_PHOSPHO_SITE': 118,
    #            'MYRISTYL': 5, 'AMIDATION': 3, 'ASN_GLYCOSYLATION': 11, 'L=0': 2, 'LEUCINE_ZIPPER': 1,
    #            'MICROBODIES_CTER': 10, 'RGD': 1, 'TYR_PHOSPHO_SITE_1': 1, 'TYR_PHOSPHO_SITE_2': 2,
    #            'CLUMP0': 6, 'CLUMP3': 3, 'CLUMP5': 4, 'CLUMP6': 11, 'CLUMP7': 9, 'CLUMP8': 5,
    #            'bin1': 40, 'bin2': 51, 'bin3': 51, 'bin4': 48}
    #
    # ref_min = {'sequence length': 33, 'signal peptide': 0.0, 'transmembrane domain': 0,
    #            'aa in tr domain': 0.0, 'first 60 aa': 0.0, 'prob N-in': 1e-05,
    #            'warning signal sequence': 0, 'MobiDB-lite': 0.0,
    #            'CAMP_PHOSPHO_SITE': 0, 'PKC_PHOSPHO_SITE': 0, 'CK2_PHOSPHO_SITE': 0,
    #            'MYRISTYL': 0, 'AMIDATION': 0, 'ASN_GLYCOSYLATION': 0, 'L=0': 0, 'LEUCINE_ZIPPER': 0,
    #            'MICROBODIES_CTER': 0, 'RGD': 0, 'TYR_PHOSPHO_SITE_1': 0, 'TYR_PHOSPHO_SITE_2': 0,
    #            'CLUMP0': 0, 'CLUMP3': 0, 'CLUMP5': 0, 'CLUMP6': 0, 'CLUMP7': 0, 'CLUMP8': 0,
    #            'bin1': 0, 'bin2': 0, 'bin3': 0, 'bin4': 0}

    # auto min & max
    ft = pd.read_csv(args.input_feature_landscape, sep=",")

    ref_max = {}
    ref_min = {}
    for col in list(ft.columns)[8:]:
        if col != 'warning signal sequence' and col != "mTMR":
            ref_max[col] = np.max(list(ft[col]))
            ref_min[col] = np.min(list(ft[col]))
        else:
            pass

    # parse new feature table
    # rename columns to corresponds to the EC_feature_landscape
    i_ft = pd.read_csv(args.input, sep="\t").rename(columns={"warning signal sequence": "mTRM",
                                                             "MobiDB-lite": "IDRs",
                                                             "L=0": "ASPARAGINE_RICH"})

    # parse LEAPH predictions
    preds = pd.read_csv(args.leaph_predictions, sep="\t")
    # take only the proteins predicted as putative pathogenic protein by at least one model in LEAPH
    pred_eff = preds[preds["pos_vote"] != "-"]
    i_ft_peff = i_ft[i_ft["seq_id"].isin(list(pred_eff["seq_id"]))]

    # initialize scaled_dict
    scaled_dict = {"seq_id": list(i_ft_peff["seq_id"])}
    for f in list(ref_max.keys()):
        if np.max(list(i_ft_peff[f])) > ref_max[f] or np.min(list(i_ft_peff[f])) < ref_min[f]:
            print("mapping warning")
        scaled_dict[f] = []

    # fill scaled_dict

    with open(f"{args.output_dir}/log_LEAPH_map.txt", "w") as out_log:
        for i in range(len(i_ft_peff)):
            for f in list(ref_max.keys()):
                if ref_max[f] > i_ft_peff[f].iloc[i] > ref_min[f]:
                    scaled_dict[f].append(minmax_scaler(ref_min[f], ref_max[f], i_ft_peff[f].iloc[i]))
                # if the value for feature in the actual predictions is > then the max value in training + WARNING
                elif ref_max[f] < i_ft_peff[f].iloc[i]:
                    out_log.write(f"{i_ft_peff['seq_id'].iloc[i]}\tWARNING\tvalue for {f} > than max in training\n")
                    scaled_dict[f].append(1)
                # if the value for feature in the actual predictions is < then the max value in training + WARNING
                elif ref_min[f] > i_ft_peff[f].iloc[i]:
                    out_log.write(f"{i_ft_peff['seq_id'].iloc[i]}\tWARNING\tvalue for {f} < than min in training\n")
                    scaled_dict[f].append(0)
                else:
                    scaled_dict[f].append(minmax_scaler(ref_min[f], ref_max[f], i_ft_peff[f].iloc[i]))

    scaled_df = pd.DataFrame(scaled_dict)
    # reorder the columns to be mapped on EffectorComb landscape
    scaled_df_reordered = scaled_df[list(ref_max.keys()) + ["seq_id"]]
    scaled_df_reordered["origin"] = ["new_prediction"] * len(i_ft_peff)
    scaled_df_reordered.to_csv(f"{args.output_dir}/{args.prefix}_scaled_ft_SOM.tsv", "\t", index=False)
    print(f"# DONE, output file saved at {args.output_dir}/{args.prefix}_scaled_ft_SOM.tsv")
